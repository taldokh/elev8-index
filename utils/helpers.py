import os
from datetime import datetime

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

import config.config as cg
from models.configuration_model import Configuration

def str_to_bool(s):
    if s:
        return s.lower() in ("true", "1", "yes", "y")
    return False


def validate_int_env_var(key: str):
    try:
        return int(os.environ.get(key))
    except:
        print(f'environment variable {key} is invalid')

def create_configuration(selection_type_top,relative_weight, equities_per_firm, number_of_firms):
    engine = create_engine(cg.DB_CONNECTION_URL)
    Session = sessionmaker(bind=engine)
    session = Session()

    try:
        config = Configuration(
            equities_per_firm=equities_per_firm,
            number_of_firms=number_of_firms,
            selection_type_top=selection_type_top,
            relative_weight=relative_weight
        )
        session.add(config)
        session.commit()
        session.refresh(config)  # Gets the autogenerated ID
        return config.id
    except Exception as e:
        print(f"error while trying to create configuration {e}")

def remove_file(path):
    if os.path.exists(path):
        try:
            os.remove(path)
            print(f"Deleted file: {path}")
        except Exception as file_err:
            print(f"Error deleting file: {file_err}")

def delete_configuration(config_id):
    engine = create_engine(cg.DB_CONNECTION_URL)
    Session = sessionmaker(bind=engine)
    session = Session()

    try:
        config = session.query(Configuration).filter_by(id=config_id).first()
        if config:
            session.delete(config)
            session.commit()
            print(f"Deleted configuration ID {config_id} and related rows.")
        else:
            print(f"No configuration found with ID {config_id} to delete.")
    except Exception as db_err:
        print(f"Error during DB rollback: {db_err}")


def is_configuration_already_exist(equities_per_firm, number_of_firms, selection_type_top, relative_weight):
    engine = create_engine(cg.DB_CONNECTION_URL)
    Session = sessionmaker(bind=engine)
    session = Session()

    try:

        # Query to check if the configuration already exists
        existing_config = session.query(Configuration).filter_by(
            equities_per_firm=equities_per_firm,
            number_of_firms=number_of_firms,
            selection_type_top=selection_type_top,
            relative_weight=relative_weight
        ).first()

        if existing_config:
            print("Configuration already exists:", existing_config.id)
            return True
        else:
            print("Configuration does not exist.")
            return False

    except Exception as e:
        print(f"Error checking configuration: {e}")
        raise e
    finally:
        session.close()


def generate_quarter_ranges(start_date, end_date):
    quarter_ranges = []
    start_year = start_date.year
    end_year = end_date.year
    # Loop through each year from the start year to the end year
    for year in range(start_year, end_year + 1):
        for i, (month, day) in enumerate(cg.REBALANCE_DATES):
            # Check if the quarter start date is within the given range
            quarter_start_date = datetime(year, month, day)
            # If the quarter starts in November, it might belong to the next year
            if month == 11:
                quarter_start_date = datetime(year, month, day)
                quarter_end_date = datetime(year + 1, 2, 15)  # Next year's February
            else:
                quarter_end_date = datetime(year, cg.REBALANCE_DATES[(i + 1) % 4][0], cg.REBALANCE_DATES[(i + 1) % 4][1])
            # Skip quarters that are outside the start and end date range
            if quarter_start_date < start_date or quarter_start_date > end_date:
                continue  # This quarter is outside the range
            # Adjust quarter end date if it exceeds the provided end_date
            if quarter_end_date > end_date:
                quarter_end_date = end_date
            quarter_ranges.append((quarter_start_date, quarter_end_date))
    return quarter_ranges
